/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.4.0.0
 */
using System.Collections.Generic;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Express
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	internal class ExpressParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(ExpressParser), "ExpressParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable root
			/// </summary>
			public const int VariableRoot = 0x000B;
			/// <summary>
			/// The unique identifier for variable comment_exp
			/// </summary>
			public const int VariableCommentExp = 0x000C;
			/// <summary>
			/// The unique identifier for variable schema_body
			/// </summary>
			public const int VariableSchemaBody = 0x000D;
			/// <summary>
			/// The unique identifier for variable use_decl
			/// </summary>
			public const int VariableUseDecl = 0x000E;
			/// <summary>
			/// The unique identifier for variable schema_decl
			/// </summary>
			public const int VariableSchemaDecl = 0x000F;
			/// <summary>
			/// The unique identifier for variable type_decl
			/// </summary>
			public const int VariableTypeDecl = 0x0010;
			/// <summary>
			/// The unique identifier for variable select_decl
			/// </summary>
			public const int VariableSelectDecl = 0x0011;
			/// <summary>
			/// The unique identifier for variable entity_decl
			/// </summary>
			public const int VariableEntityDecl = 0x0012;
			/// <summary>
			/// The unique identifier for variable abstract_decl
			/// </summary>
			public const int VariableAbstractDecl = 0x0013;
			/// <summary>
			/// The unique identifier for variable supertype_decl
			/// </summary>
			public const int VariableSupertypeDecl = 0x0014;
			/// <summary>
			/// The unique identifier for variable subtype_decl
			/// </summary>
			public const int VariableSubtypeDecl = 0x0015;
			/// <summary>
			/// The unique identifier for variable att_decl
			/// </summary>
			public const int VariableAttDecl = 0x0016;
			/// <summary>
			/// The unique identifier for variable where_decl
			/// </summary>
			public const int VariableWhereDecl = 0x0017;
			/// <summary>
			/// The unique identifier for variable or_exp
			/// </summary>
			public const int VariableOrExp = 0x0018;
			/// <summary>
			/// The unique identifier for variable and_exp
			/// </summary>
			public const int VariableAndExp = 0x0019;
			/// <summary>
			/// The unique identifier for variable unary_exp
			/// </summary>
			public const int VariableUnaryExp = 0x001A;
			/// <summary>
			/// The unique identifier for variable atom_exp
			/// </summary>
			public const int VariableAtomExp = 0x001B;
			/// <summary>
			/// The unique identifier for variable exists_exp
			/// </summary>
			public const int VariableExistsExp = 0x001C;
			/// <summary>
			/// The unique identifier for variable limits_exp
			/// </summary>
			public const int VariableLimitsExp = 0x001D;
			/// <summary>
			/// The unique identifier for variable comp_exp
			/// </summary>
			public const int VariableCompExp = 0x001E;
			/// <summary>
			/// The unique identifier for variable comp_op
			/// </summary>
			public const int VariableCompOp = 0x001F;
			/// <summary>
			/// The unique identifier for variable num_op
			/// </summary>
			public const int VariableNumOp = 0x0020;
			/// <summary>
			/// The unique identifier for variable lt_comp_op
			/// </summary>
			public const int VariableLtCompOp = 0x0021;
			/// <summary>
			/// The unique identifier for variable gt_comp_op
			/// </summary>
			public const int VariableGtCompOp = 0x0022;
			/// <summary>
			/// The unique identifier for variable selector_exp
			/// </summary>
			public const int VariableSelectorExp = 0x0023;
			/// <summary>
			/// The unique identifier for variable type_id
			/// </summary>
			public const int VariableTypeId = 0x0024;
			/// <summary>
			/// The unique identifier for variable pt_keyword
			/// </summary>
			public const int VariablePtKeyword = 0x0025;
			/// <summary>
			/// The unique identifier for variable literal
			/// </summary>
			public const int VariableLiteral = 0x0026;
			/// <summary>
			/// The unique identifier for variable numeric_lit
			/// </summary>
			public const int VariableNumericLit = 0x0027;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x000B, "root"), 
			new Symbol(0x000C, "comment_exp"), 
			new Symbol(0x000D, "schema_body"), 
			new Symbol(0x000E, "use_decl"), 
			new Symbol(0x000F, "schema_decl"), 
			new Symbol(0x0010, "type_decl"), 
			new Symbol(0x0011, "select_decl"), 
			new Symbol(0x0012, "entity_decl"), 
			new Symbol(0x0013, "abstract_decl"), 
			new Symbol(0x0014, "supertype_decl"), 
			new Symbol(0x0015, "subtype_decl"), 
			new Symbol(0x0016, "att_decl"), 
			new Symbol(0x0017, "where_decl"), 
			new Symbol(0x0018, "or_exp"), 
			new Symbol(0x0019, "and_exp"), 
			new Symbol(0x001A, "unary_exp"), 
			new Symbol(0x001B, "atom_exp"), 
			new Symbol(0x001C, "exists_exp"), 
			new Symbol(0x001D, "limits_exp"), 
			new Symbol(0x001E, "comp_exp"), 
			new Symbol(0x001F, "comp_op"), 
			new Symbol(0x0020, "num_op"), 
			new Symbol(0x0021, "lt_comp_op"), 
			new Symbol(0x0022, "gt_comp_op"), 
			new Symbol(0x0023, "selector_exp"), 
			new Symbol(0x0024, "type_id"), 
			new Symbol(0x0025, "pt_keyword"), 
			new Symbol(0x0026, "literal"), 
			new Symbol(0x0027, "numeric_lit"), 
			new Symbol(0x0028, "__V40"), 
			new Symbol(0x0029, "__V41"), 
			new Symbol(0x0034, "__V52"), 
			new Symbol(0x0037, "__V55"), 
			new Symbol(0x003C, "__V60"), 
			new Symbol(0x0041, "__V65"), 
			new Symbol(0x004E, "__V78"), 
			new Symbol(0x0058, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public ExpressParser(ExpressLexer lexer) : base (commonAutomaton, variables, virtuals, null, lexer) { }

		/// <summary>
		/// Visitor interface
		/// </summary>
		public class Visitor
		{
			public virtual void OnTerminalNewLine(ASTNode node) {}
			public virtual void OnTerminalWhiteSpace(ASTNode node) {}
			public virtual void OnTerminalSeparator(ASTNode node) {}
			public virtual void OnTerminalIdentifier(ASTNode node) {}
			public virtual void OnTerminalAnnotation(ASTNode node) {}
			public virtual void OnTerminalIntegerLiteralDecimal(ASTNode node) {}
			public virtual void OnTerminalIntegerLiteralHexa(ASTNode node) {}
			public virtual void OnTerminalRealLiteral(ASTNode node) {}
			public virtual void OnVariableRoot(ASTNode node) {}
			public virtual void OnVariableCommentExp(ASTNode node) {}
			public virtual void OnVariableSchemaBody(ASTNode node) {}
			public virtual void OnVariableUseDecl(ASTNode node) {}
			public virtual void OnVariableSchemaDecl(ASTNode node) {}
			public virtual void OnVariableTypeDecl(ASTNode node) {}
			public virtual void OnVariableSelectDecl(ASTNode node) {}
			public virtual void OnVariableEntityDecl(ASTNode node) {}
			public virtual void OnVariableAbstractDecl(ASTNode node) {}
			public virtual void OnVariableSupertypeDecl(ASTNode node) {}
			public virtual void OnVariableSubtypeDecl(ASTNode node) {}
			public virtual void OnVariableAttDecl(ASTNode node) {}
			public virtual void OnVariableWhereDecl(ASTNode node) {}
			public virtual void OnVariableOrExp(ASTNode node) {}
			public virtual void OnVariableAndExp(ASTNode node) {}
			public virtual void OnVariableUnaryExp(ASTNode node) {}
			public virtual void OnVariableAtomExp(ASTNode node) {}
			public virtual void OnVariableExistsExp(ASTNode node) {}
			public virtual void OnVariableLimitsExp(ASTNode node) {}
			public virtual void OnVariableCompExp(ASTNode node) {}
			public virtual void OnVariableCompOp(ASTNode node) {}
			public virtual void OnVariableNumOp(ASTNode node) {}
			public virtual void OnVariableLtCompOp(ASTNode node) {}
			public virtual void OnVariableGtCompOp(ASTNode node) {}
			public virtual void OnVariableSelectorExp(ASTNode node) {}
			public virtual void OnVariableTypeId(ASTNode node) {}
			public virtual void OnVariablePtKeyword(ASTNode node) {}
			public virtual void OnVariableLiteral(ASTNode node) {}
			public virtual void OnVariableNumericLit(ASTNode node) {}
		}

		/// <summary>
		/// Walk the AST using a visitor
		/// </summary>
		public static void Visit(ParseResult result, Visitor visitor)
		{
			VisitASTNode(result.Root, visitor);
		}

		/// <summary>
		/// Walk the AST using a visitor
		/// </summary>
		public static void VisitASTNode(ASTNode node, Visitor visitor)
		{
			for (int i = 0; i < node.Children.Count; i++)
				VisitASTNode(node.Children[i], visitor);
			switch(node.Symbol.ID)
			{
				case 0x0003: visitor.OnTerminalNewLine(node); break;
				case 0x0004: visitor.OnTerminalWhiteSpace(node); break;
				case 0x0005: visitor.OnTerminalSeparator(node); break;
				case 0x0006: visitor.OnTerminalIdentifier(node); break;
				case 0x0007: visitor.OnTerminalAnnotation(node); break;
				case 0x0008: visitor.OnTerminalIntegerLiteralDecimal(node); break;
				case 0x0009: visitor.OnTerminalIntegerLiteralHexa(node); break;
				case 0x000A: visitor.OnTerminalRealLiteral(node); break;
				case 0x000B: visitor.OnVariableRoot(node); break;
				case 0x000C: visitor.OnVariableCommentExp(node); break;
				case 0x000D: visitor.OnVariableSchemaBody(node); break;
				case 0x000E: visitor.OnVariableUseDecl(node); break;
				case 0x000F: visitor.OnVariableSchemaDecl(node); break;
				case 0x0010: visitor.OnVariableTypeDecl(node); break;
				case 0x0011: visitor.OnVariableSelectDecl(node); break;
				case 0x0012: visitor.OnVariableEntityDecl(node); break;
				case 0x0013: visitor.OnVariableAbstractDecl(node); break;
				case 0x0014: visitor.OnVariableSupertypeDecl(node); break;
				case 0x0015: visitor.OnVariableSubtypeDecl(node); break;
				case 0x0016: visitor.OnVariableAttDecl(node); break;
				case 0x0017: visitor.OnVariableWhereDecl(node); break;
				case 0x0018: visitor.OnVariableOrExp(node); break;
				case 0x0019: visitor.OnVariableAndExp(node); break;
				case 0x001A: visitor.OnVariableUnaryExp(node); break;
				case 0x001B: visitor.OnVariableAtomExp(node); break;
				case 0x001C: visitor.OnVariableExistsExp(node); break;
				case 0x001D: visitor.OnVariableLimitsExp(node); break;
				case 0x001E: visitor.OnVariableCompExp(node); break;
				case 0x001F: visitor.OnVariableCompOp(node); break;
				case 0x0020: visitor.OnVariableNumOp(node); break;
				case 0x0021: visitor.OnVariableLtCompOp(node); break;
				case 0x0022: visitor.OnVariableGtCompOp(node); break;
				case 0x0023: visitor.OnVariableSelectorExp(node); break;
				case 0x0024: visitor.OnVariableTypeId(node); break;
				case 0x0025: visitor.OnVariablePtKeyword(node); break;
				case 0x0026: visitor.OnVariableLiteral(node); break;
				case 0x0027: visitor.OnVariableNumericLit(node); break;
			}
		}
	}
}
