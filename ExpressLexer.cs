/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.4.0.0
 */
using System.Collections.Generic;
using System.IO;
using Hime.Redist;
using Hime.Redist.Lexer;

namespace Express
{
	/// <summary>
	/// Represents a lexer
	/// </summary>
	internal class ExpressLexer : ContextFreeLexer
	{
		/// <summary>
		/// The automaton for this lexer
		/// </summary>
		private static readonly Automaton commonAutomaton = Automaton.Find(typeof(ExpressLexer), "ExpressLexer.bin");
		/// <summary>
		/// Contains the constant IDs for the terminals for this lexer
		/// </summary>
		public class ID
		{
			/// <summary>
			/// The unique identifier for terminal NEW_LINE
			/// </summary>
			public const int TerminalNewLine = 0x0003;
			/// <summary>
			/// The unique identifier for terminal WHITE_SPACE
			/// </summary>
			public const int TerminalWhiteSpace = 0x0004;
			/// <summary>
			/// The unique identifier for terminal SEPARATOR
			/// </summary>
			public const int TerminalSeparator = 0x0005;
			/// <summary>
			/// The unique identifier for terminal IDENTIFIER
			/// </summary>
			public const int TerminalIdentifier = 0x0006;
			/// <summary>
			/// The unique identifier for terminal ANNOTATION
			/// </summary>
			public const int TerminalAnnotation = 0x0007;
			/// <summary>
			/// The unique identifier for terminal INLINE_ANNOTATION
			/// </summary>
			public const int TerminalInlineAnnotation = 0x0008;
			/// <summary>
			/// The unique identifier for terminal INTEGER_LITERAL_DECIMAL
			/// </summary>
			public const int TerminalIntegerLiteralDecimal = 0x0009;
			/// <summary>
			/// The unique identifier for terminal INTEGER_LITERAL_HEXA
			/// </summary>
			public const int TerminalIntegerLiteralHexa = 0x000A;
			/// <summary>
			/// The unique identifier for terminal REAL_LITERAL
			/// </summary>
			public const int TerminalRealLiteral = 0x000B;
			/// <summary>
			/// The unique identifier for terminal STRING_LITERAL
			/// </summary>
			public const int TerminalStringLiteral = 0x000C;
		}
		/// <summary>
		/// Contains the constant IDs for the contexts for this lexer
		/// </summary>
		public class Context
		{
			/// <summary>
			/// The unique identifier for the default context
			/// </summary>
			public const int Default = 0;
		}
		/// <summary>
		/// The collection of terminals matched by this lexer
		/// </summary>
		/// <remarks>
		/// The terminals are in an order consistent with the automaton,
		/// so that terminal indices in the automaton can be used to retrieve the terminals in this table
		/// </remarks>
		private static readonly Symbol[] terminals = {
			new Symbol(0x0001, "Îµ"),
			new Symbol(0x0002, "$"),
			new Symbol(0x0003, "NEW_LINE"),
			new Symbol(0x0004, "WHITE_SPACE"),
			new Symbol(0x0005, "SEPARATOR"),
			new Symbol(0x0006, "IDENTIFIER"),
			new Symbol(0x0007, "ANNOTATION"),
			new Symbol(0x0008, "INLINE_ANNOTATION"),
			new Symbol(0x0009, "INTEGER_LITERAL_DECIMAL"),
			new Symbol(0x000A, "INTEGER_LITERAL_HEXA"),
			new Symbol(0x000B, "REAL_LITERAL"),
			new Symbol(0x000C, "STRING_LITERAL"),
			new Symbol(0x0047, "USE"),
			new Symbol(0x0048, "FROM"),
			new Symbol(0x0049, ";"),
			new Symbol(0x004A, "SCHEMA"),
			new Symbol(0x004B, "TYPE"),
			new Symbol(0x004C, "="),
			new Symbol(0x004D, "END_TYPE"),
			new Symbol(0x004E, "SELECT"),
			new Symbol(0x004F, "("),
			new Symbol(0x0050, ","),
			new Symbol(0x0052, ")"),
			new Symbol(0x0053, "ENTITY"),
			new Symbol(0x0056, "END_ENTITY"),
			new Symbol(0x0057, "ENUMERATION"),
			new Symbol(0x0058, "OF"),
			new Symbol(0x005A, "ABSTRACT"),
			new Symbol(0x005B, "SUBTYPE"),
			new Symbol(0x005D, "SUPERTYPE"),
			new Symbol(0x005E, "DERIVE"),
			new Symbol(0x0061, ":"),
			new Symbol(0x0062, ":="),
			new Symbol(0x0064, "UNIQUE"),
			new Symbol(0x0069, "SELF"),
			new Symbol(0x006A, "SELF\\"),
			new Symbol(0x006B, "\\"),
			new Symbol(0x006C, "."),
			new Symbol(0x006E, "["),
			new Symbol(0x006F, "]"),
			new Symbol(0x0070, "LIST"),
			new Symbol(0x0071, "*"),
			new Symbol(0x0074, "SET"),
			new Symbol(0x0075, "ARRAY"),
			new Symbol(0x0076, "BAG"),
			new Symbol(0x0077, "QUERY"),
			new Symbol(0x0078, "|"),
			new Symbol(0x0079, "?"),
			new Symbol(0x007A, "OPTIONAL"),
			new Symbol(0x007B, "WHERE"),
			new Symbol(0x007F, "OR"),
			new Symbol(0x0080, "AND"),
			new Symbol(0x0081, "NOT"),
			new Symbol(0x0082, "EXISTS"),
			new Symbol(0x0083, "{"),
			new Symbol(0x0084, "}"),
			new Symbol(0x0086, "TYPEOF"),
			new Symbol(0x0087, "USEDIN"),
			new Symbol(0x0089, "SIZEOF"),
			new Symbol(0x008A, ":<>:"),
			new Symbol(0x008B, ":=:"),
			new Symbol(0x008C, "<>"),
			new Symbol(0x008D, "IN"),
			new Symbol(0x008E, "<"),
			new Symbol(0x008F, "<="),
			new Symbol(0x0090, "<*"),
			new Symbol(0x0091, ">="),
			new Symbol(0x0092, ">"),
			new Symbol(0x0093, ">*"),
			new Symbol(0x0094, "ONEOF"),
			new Symbol(0x0096, "ANDOR"),
			new Symbol(0x0098, "+"),
			new Symbol(0x009A, "STRING"),
			new Symbol(0x009B, "NUMBER"),
			new Symbol(0x009C, "BOOLEAN"),
			new Symbol(0x009D, "LOGICAL"),
			new Symbol(0x009E, "BINARY"),
			new Symbol(0x009F, "INTEGER"),
			new Symbol(0x00A0, "REAL"),
			new Symbol(0x00A1, "true"),
			new Symbol(0x00A2, "false") };
		/// <summary>
		/// Initializes a new instance of the lexer
		/// </summary>
		/// <param name="input">The lexer's input</param>
		public ExpressLexer(string input) : base(commonAutomaton, terminals, 0x0005, input) {}
		/// <summary>
		/// Initializes a new instance of the lexer
		/// </summary>
		/// <param name="input">The lexer's input</param>
		public ExpressLexer(TextReader input) : base(commonAutomaton, terminals, 0x0005, input) {}
	}
}
