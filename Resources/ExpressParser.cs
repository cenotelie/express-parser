/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.4.0.0
 */
using System.Collections.Generic;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Express
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	internal class ExpressParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(ExpressParser), "ExpressParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable root
			/// </summary>
			public const int VariableRoot = 0x0011;
			/// <summary>
			/// The unique identifier for variable comment_exp
			/// </summary>
			public const int VariableCommentExp = 0x0012;
			/// <summary>
			/// The unique identifier for variable use_decl
			/// </summary>
			public const int VariableUseDecl = 0x0013;
			/// <summary>
			/// The unique identifier for variable reference_decl
			/// </summary>
			public const int VariableReferenceDecl = 0x0014;
			/// <summary>
			/// The unique identifier for variable constant_decl
			/// </summary>
			public const int VariableConstantDecl = 0x0015;
			/// <summary>
			/// The unique identifier for variable schema_decl
			/// </summary>
			public const int VariableSchemaDecl = 0x0016;
			/// <summary>
			/// The unique identifier for variable type_decl
			/// </summary>
			public const int VariableTypeDecl = 0x0017;
			/// <summary>
			/// The unique identifier for variable based_on_exp
			/// </summary>
			public const int VariableBasedOnExp = 0x0018;
			/// <summary>
			/// The unique identifier for variable select_decl
			/// </summary>
			public const int VariableSelectDecl = 0x0019;
			/// <summary>
			/// The unique identifier for variable entity_decl
			/// </summary>
			public const int VariableEntityDecl = 0x001A;
			/// <summary>
			/// The unique identifier for variable enum_decl
			/// </summary>
			public const int VariableEnumDecl = 0x001B;
			/// <summary>
			/// The unique identifier for variable subtype_const_decl
			/// </summary>
			public const int VariableSubtypeConstDecl = 0x001C;
			/// <summary>
			/// The unique identifier for variable function_decl
			/// </summary>
			public const int VariableFunctionDecl = 0x001D;
			/// <summary>
			/// The unique identifier for variable statement_exp
			/// </summary>
			public const int VariableStatementExp = 0x001E;
			/// <summary>
			/// The unique identifier for variable local_decl
			/// </summary>
			public const int VariableLocalDecl = 0x001F;
			/// <summary>
			/// The unique identifier for variable if_decl
			/// </summary>
			public const int VariableIfDecl = 0x0020;
			/// <summary>
			/// The unique identifier for variable return_statement
			/// </summary>
			public const int VariableReturnStatement = 0x0021;
			/// <summary>
			/// The unique identifier for variable rule_decl
			/// </summary>
			public const int VariableRuleDecl = 0x0022;
			/// <summary>
			/// The unique identifier for variable supertype_decl
			/// </summary>
			public const int VariableSupertypeDecl = 0x0023;
			/// <summary>
			/// The unique identifier for variable subtype_decl
			/// </summary>
			public const int VariableSubtypeDecl = 0x0024;
			/// <summary>
			/// The unique identifier for variable inverse_decl
			/// </summary>
			public const int VariableInverseDecl = 0x0025;
			/// <summary>
			/// The unique identifier for variable inverse_exp
			/// </summary>
			public const int VariableInverseExp = 0x0026;
			/// <summary>
			/// The unique identifier for variable derive_decl
			/// </summary>
			public const int VariableDeriveDecl = 0x0027;
			/// <summary>
			/// The unique identifier for variable derive_exp
			/// </summary>
			public const int VariableDeriveExp = 0x0028;
			/// <summary>
			/// The unique identifier for variable unique_decl
			/// </summary>
			public const int VariableUniqueDecl = 0x0029;
			/// <summary>
			/// The unique identifier for variable unique_exp
			/// </summary>
			public const int VariableUniqueExp = 0x002A;
			/// <summary>
			/// The unique identifier for variable attr_read_exp
			/// </summary>
			public const int VariableAttrReadExp = 0x002B;
			/// <summary>
			/// The unique identifier for variable prop_decl
			/// </summary>
			public const int VariablePropDecl = 0x002C;
			/// <summary>
			/// The unique identifier for variable renamed_exp
			/// </summary>
			public const int VariableRenamedExp = 0x002D;
			/// <summary>
			/// The unique identifier for variable list_decl
			/// </summary>
			public const int VariableListDecl = 0x002E;
			/// <summary>
			/// The unique identifier for variable list_concat_exp
			/// </summary>
			public const int VariableListConcatExp = 0x002F;
			/// <summary>
			/// The unique identifier for variable list_concat_opd
			/// </summary>
			public const int VariableListConcatOpd = 0x0030;
			/// <summary>
			/// The unique identifier for variable list_ext
			/// </summary>
			public const int VariableListExt = 0x0031;
			/// <summary>
			/// The unique identifier for variable set_decl
			/// </summary>
			public const int VariableSetDecl = 0x0032;
			/// <summary>
			/// The unique identifier for variable array_decl
			/// </summary>
			public const int VariableArrayDecl = 0x0033;
			/// <summary>
			/// The unique identifier for variable bag_decl
			/// </summary>
			public const int VariableBagDecl = 0x0034;
			/// <summary>
			/// The unique identifier for variable array_exp
			/// </summary>
			public const int VariableArrayExp = 0x0035;
			/// <summary>
			/// The unique identifier for variable optional_decl
			/// </summary>
			public const int VariableOptionalDecl = 0x0036;
			/// <summary>
			/// The unique identifier for variable where_decl
			/// </summary>
			public const int VariableWhereDecl = 0x0037;
			/// <summary>
			/// The unique identifier for variable rule_exp
			/// </summary>
			public const int VariableRuleExp = 0x0038;
			/// <summary>
			/// The unique identifier for variable bool_exp
			/// </summary>
			public const int VariableBoolExp = 0x0039;
			/// <summary>
			/// The unique identifier for variable xor_exp
			/// </summary>
			public const int VariableXorExp = 0x003A;
			/// <summary>
			/// The unique identifier for variable and_exp
			/// </summary>
			public const int VariableAndExp = 0x003B;
			/// <summary>
			/// The unique identifier for variable unary_exp
			/// </summary>
			public const int VariableUnaryExp = 0x003C;
			/// <summary>
			/// The unique identifier for variable atom_exp
			/// </summary>
			public const int VariableAtomExp = 0x003D;
			/// <summary>
			/// The unique identifier for variable exists_exp
			/// </summary>
			public const int VariableExistsExp = 0x003E;
			/// <summary>
			/// The unique identifier for variable query_exp
			/// </summary>
			public const int VariableQueryExp = 0x003F;
			/// <summary>
			/// The unique identifier for variable limits_exp
			/// </summary>
			public const int VariableLimitsExp = 0x0040;
			/// <summary>
			/// The unique identifier for variable comp_exp
			/// </summary>
			public const int VariableCompExp = 0x0041;
			/// <summary>
			/// The unique identifier for variable comp_opd
			/// </summary>
			public const int VariableCompOpd = 0x0042;
			/// <summary>
			/// The unique identifier for variable function_call_exp
			/// </summary>
			public const int VariableFunctionCallExp = 0x0043;
			/// <summary>
			/// The unique identifier for variable function_params_exp
			/// </summary>
			public const int VariableFunctionParamsExp = 0x0044;
			/// <summary>
			/// The unique identifier for variable typeof_opd
			/// </summary>
			public const int VariableTypeofOpd = 0x0045;
			/// <summary>
			/// The unique identifier for variable usedin_opd
			/// </summary>
			public const int VariableUsedinOpd = 0x0046;
			/// <summary>
			/// The unique identifier for variable access_opd
			/// </summary>
			public const int VariableAccessOpd = 0x0047;
			/// <summary>
			/// The unique identifier for variable sizeof_opd
			/// </summary>
			public const int VariableSizeofOpd = 0x0048;
			/// <summary>
			/// The unique identifier for variable classof_opd
			/// </summary>
			public const int VariableClassofOpd = 0x0049;
			/// <summary>
			/// The unique identifier for variable comp_op
			/// </summary>
			public const int VariableCompOp = 0x004A;
			/// <summary>
			/// The unique identifier for variable eq_op
			/// </summary>
			public const int VariableEqOp = 0x004B;
			/// <summary>
			/// The unique identifier for variable in_op
			/// </summary>
			public const int VariableInOp = 0x004C;
			/// <summary>
			/// The unique identifier for variable num_op
			/// </summary>
			public const int VariableNumOp = 0x004D;
			/// <summary>
			/// The unique identifier for variable lt_comp_op
			/// </summary>
			public const int VariableLtCompOp = 0x004E;
			/// <summary>
			/// The unique identifier for variable gt_comp_op
			/// </summary>
			public const int VariableGtCompOp = 0x004F;
			/// <summary>
			/// The unique identifier for variable oneof_exp
			/// </summary>
			public const int VariableOneofExp = 0x0050;
			/// <summary>
			/// The unique identifier for variable andor_exp
			/// </summary>
			public const int VariableAndorExp = 0x0051;
			/// <summary>
			/// The unique identifier for variable str_concat_exp
			/// </summary>
			public const int VariableStrConcatExp = 0x0052;
			/// <summary>
			/// The unique identifier for variable list_append_exp
			/// </summary>
			public const int VariableListAppendExp = 0x0053;
			/// <summary>
			/// The unique identifier for variable type_id
			/// </summary>
			public const int VariableTypeId = 0x0054;
			/// <summary>
			/// The unique identifier for variable pt_keyword
			/// </summary>
			public const int VariablePtKeyword = 0x0055;
			/// <summary>
			/// The unique identifier for variable literal
			/// </summary>
			public const int VariableLiteral = 0x0056;
			/// <summary>
			/// The unique identifier for variable numeric_lit
			/// </summary>
			public const int VariableNumericLit = 0x0057;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x0011, "root"), 
			new Symbol(0x0012, "comment_exp"), 
			new Symbol(0x0013, "use_decl"), 
			new Symbol(0x0014, "reference_decl"), 
			new Symbol(0x0015, "constant_decl"), 
			new Symbol(0x0016, "schema_decl"), 
			new Symbol(0x0017, "type_decl"), 
			new Symbol(0x0018, "based_on_exp"), 
			new Symbol(0x0019, "select_decl"), 
			new Symbol(0x001A, "entity_decl"), 
			new Symbol(0x001B, "enum_decl"), 
			new Symbol(0x001C, "subtype_const_decl"), 
			new Symbol(0x001D, "function_decl"), 
			new Symbol(0x001E, "statement_exp"), 
			new Symbol(0x001F, "local_decl"), 
			new Symbol(0x0020, "if_decl"), 
			new Symbol(0x0021, "return_statement"), 
			new Symbol(0x0022, "rule_decl"), 
			new Symbol(0x0023, "supertype_decl"), 
			new Symbol(0x0024, "subtype_decl"), 
			new Symbol(0x0025, "inverse_decl"), 
			new Symbol(0x0026, "inverse_exp"), 
			new Symbol(0x0027, "derive_decl"), 
			new Symbol(0x0028, "derive_exp"), 
			new Symbol(0x0029, "unique_decl"), 
			new Symbol(0x002A, "unique_exp"), 
			new Symbol(0x002B, "attr_read_exp"), 
			new Symbol(0x002C, "prop_decl"), 
			new Symbol(0x002D, "renamed_exp"), 
			new Symbol(0x002E, "list_decl"), 
			new Symbol(0x002F, "list_concat_exp"), 
			new Symbol(0x0030, "list_concat_opd"), 
			new Symbol(0x0031, "list_ext"), 
			new Symbol(0x0032, "set_decl"), 
			new Symbol(0x0033, "array_decl"), 
			new Symbol(0x0034, "bag_decl"), 
			new Symbol(0x0035, "array_exp"), 
			new Symbol(0x0036, "optional_decl"), 
			new Symbol(0x0037, "where_decl"), 
			new Symbol(0x0038, "rule_exp"), 
			new Symbol(0x0039, "bool_exp"), 
			new Symbol(0x003A, "xor_exp"), 
			new Symbol(0x003B, "and_exp"), 
			new Symbol(0x003C, "unary_exp"), 
			new Symbol(0x003D, "atom_exp"), 
			new Symbol(0x003E, "exists_exp"), 
			new Symbol(0x003F, "query_exp"), 
			new Symbol(0x0040, "limits_exp"), 
			new Symbol(0x0041, "comp_exp"), 
			new Symbol(0x0042, "comp_opd"), 
			new Symbol(0x0043, "function_call_exp"), 
			new Symbol(0x0044, "function_params_exp"), 
			new Symbol(0x0045, "typeof_opd"), 
			new Symbol(0x0046, "usedin_opd"), 
			new Symbol(0x0047, "access_opd"), 
			new Symbol(0x0048, "sizeof_opd"), 
			new Symbol(0x0049, "classof_opd"), 
			new Symbol(0x004A, "comp_op"), 
			new Symbol(0x004B, "eq_op"), 
			new Symbol(0x004C, "in_op"), 
			new Symbol(0x004D, "num_op"), 
			new Symbol(0x004E, "lt_comp_op"), 
			new Symbol(0x004F, "gt_comp_op"), 
			new Symbol(0x0050, "oneof_exp"), 
			new Symbol(0x0051, "andor_exp"), 
			new Symbol(0x0052, "str_concat_exp"), 
			new Symbol(0x0053, "list_append_exp"), 
			new Symbol(0x0054, "type_id"), 
			new Symbol(0x0055, "pt_keyword"), 
			new Symbol(0x0056, "literal"), 
			new Symbol(0x0057, "numeric_lit"), 
			new Symbol(0x0058, "__V88"), 
			new Symbol(0x0059, "__V89"), 
			new Symbol(0x005E, "__V94"), 
			new Symbol(0x0062, "__V98"), 
			new Symbol(0x0064, "__V100"), 
			new Symbol(0x006D, "__V109"), 
			new Symbol(0x006F, "__V111"), 
			new Symbol(0x0072, "__V114"), 
			new Symbol(0x0073, "__V115"), 
			new Symbol(0x0077, "__V119"), 
			new Symbol(0x007D, "__V125"), 
			new Symbol(0x0081, "__V129"), 
			new Symbol(0x0085, "__V133"), 
			new Symbol(0x0087, "__V135"), 
			new Symbol(0x0088, "__V136"), 
			new Symbol(0x008A, "__V138"), 
			new Symbol(0x008C, "__V140"), 
			new Symbol(0x008D, "__V141"), 
			new Symbol(0x008F, "__V143"), 
			new Symbol(0x0091, "__V145"), 
			new Symbol(0x0092, "__V146"), 
			new Symbol(0x0093, "__V147"), 
			new Symbol(0x0094, "__V148"), 
			new Symbol(0x009A, "__V154"), 
			new Symbol(0x009E, "__V158"), 
			new Symbol(0x009F, "__V159"), 
			new Symbol(0x00A6, "__V166"), 
			new Symbol(0x00A7, "__V167"), 
			new Symbol(0x00A8, "__V168"), 
			new Symbol(0x00B0, "__V176"), 
			new Symbol(0x00B3, "__V179"), 
			new Symbol(0x00B6, "__V182"), 
			new Symbol(0x00C4, "__V196"), 
			new Symbol(0x00C6, "__V198"), 
			new Symbol(0x00C8, "__V200"), 
			new Symbol(0x00D0, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public ExpressParser(ExpressLexer lexer) : base (commonAutomaton, variables, virtuals, null, lexer) { }

		/// <summary>
		/// Visitor interface
		/// </summary>
		public class Visitor
		{
			public virtual void OnTerminalNewLine(ASTNode node) {}
			public virtual void OnTerminalWhiteSpace(ASTNode node) {}
			public virtual void OnTerminalSeparator(ASTNode node) {}
			public virtual void OnTerminalIdentifier(ASTNode node) {}
			public virtual void OnTerminalAnnotation(ASTNode node) {}
			public virtual void OnTerminalInlineAnnotation(ASTNode node) {}
			public virtual void OnTerminalIntegerLiteralDecimal(ASTNode node) {}
			public virtual void OnTerminalIntegerLiteralHexa(ASTNode node) {}
			public virtual void OnTerminalRealLiteral(ASTNode node) {}
			public virtual void OnTerminalBoolLiteral(ASTNode node) {}
			public virtual void OnTerminalStringLiteral(ASTNode node) {}
			public virtual void OnTerminalFunctionBody(ASTNode node) {}
			public virtual void OnTerminalConstantBody(ASTNode node) {}
			public virtual void OnTerminalRuleBody(ASTNode node) {}
			public virtual void OnVariableRoot(ASTNode node) {}
			public virtual void OnVariableCommentExp(ASTNode node) {}
			public virtual void OnVariableUseDecl(ASTNode node) {}
			public virtual void OnVariableReferenceDecl(ASTNode node) {}
			public virtual void OnVariableConstantDecl(ASTNode node) {}
			public virtual void OnVariableSchemaDecl(ASTNode node) {}
			public virtual void OnVariableTypeDecl(ASTNode node) {}
			public virtual void OnVariableBasedOnExp(ASTNode node) {}
			public virtual void OnVariableSelectDecl(ASTNode node) {}
			public virtual void OnVariableEntityDecl(ASTNode node) {}
			public virtual void OnVariableEnumDecl(ASTNode node) {}
			public virtual void OnVariableSubtypeConstDecl(ASTNode node) {}
			public virtual void OnVariableFunctionDecl(ASTNode node) {}
			public virtual void OnVariableStatementExp(ASTNode node) {}
			public virtual void OnVariableLocalDecl(ASTNode node) {}
			public virtual void OnVariableIfDecl(ASTNode node) {}
			public virtual void OnVariableReturnStatement(ASTNode node) {}
			public virtual void OnVariableRuleDecl(ASTNode node) {}
			public virtual void OnVariableSupertypeDecl(ASTNode node) {}
			public virtual void OnVariableSubtypeDecl(ASTNode node) {}
			public virtual void OnVariableInverseDecl(ASTNode node) {}
			public virtual void OnVariableInverseExp(ASTNode node) {}
			public virtual void OnVariableDeriveDecl(ASTNode node) {}
			public virtual void OnVariableDeriveExp(ASTNode node) {}
			public virtual void OnVariableUniqueDecl(ASTNode node) {}
			public virtual void OnVariableUniqueExp(ASTNode node) {}
			public virtual void OnVariableAttrReadExp(ASTNode node) {}
			public virtual void OnVariablePropDecl(ASTNode node) {}
			public virtual void OnVariableRenamedExp(ASTNode node) {}
			public virtual void OnVariableListDecl(ASTNode node) {}
			public virtual void OnVariableListConcatExp(ASTNode node) {}
			public virtual void OnVariableListConcatOpd(ASTNode node) {}
			public virtual void OnVariableListExt(ASTNode node) {}
			public virtual void OnVariableSetDecl(ASTNode node) {}
			public virtual void OnVariableArrayDecl(ASTNode node) {}
			public virtual void OnVariableBagDecl(ASTNode node) {}
			public virtual void OnVariableArrayExp(ASTNode node) {}
			public virtual void OnVariableOptionalDecl(ASTNode node) {}
			public virtual void OnVariableWhereDecl(ASTNode node) {}
			public virtual void OnVariableRuleExp(ASTNode node) {}
			public virtual void OnVariableBoolExp(ASTNode node) {}
			public virtual void OnVariableXorExp(ASTNode node) {}
			public virtual void OnVariableAndExp(ASTNode node) {}
			public virtual void OnVariableUnaryExp(ASTNode node) {}
			public virtual void OnVariableAtomExp(ASTNode node) {}
			public virtual void OnVariableExistsExp(ASTNode node) {}
			public virtual void OnVariableQueryExp(ASTNode node) {}
			public virtual void OnVariableLimitsExp(ASTNode node) {}
			public virtual void OnVariableCompExp(ASTNode node) {}
			public virtual void OnVariableCompOpd(ASTNode node) {}
			public virtual void OnVariableFunctionCallExp(ASTNode node) {}
			public virtual void OnVariableFunctionParamsExp(ASTNode node) {}
			public virtual void OnVariableTypeofOpd(ASTNode node) {}
			public virtual void OnVariableUsedinOpd(ASTNode node) {}
			public virtual void OnVariableAccessOpd(ASTNode node) {}
			public virtual void OnVariableSizeofOpd(ASTNode node) {}
			public virtual void OnVariableClassofOpd(ASTNode node) {}
			public virtual void OnVariableCompOp(ASTNode node) {}
			public virtual void OnVariableEqOp(ASTNode node) {}
			public virtual void OnVariableInOp(ASTNode node) {}
			public virtual void OnVariableNumOp(ASTNode node) {}
			public virtual void OnVariableLtCompOp(ASTNode node) {}
			public virtual void OnVariableGtCompOp(ASTNode node) {}
			public virtual void OnVariableOneofExp(ASTNode node) {}
			public virtual void OnVariableAndorExp(ASTNode node) {}
			public virtual void OnVariableStrConcatExp(ASTNode node) {}
			public virtual void OnVariableListAppendExp(ASTNode node) {}
			public virtual void OnVariableTypeId(ASTNode node) {}
			public virtual void OnVariablePtKeyword(ASTNode node) {}
			public virtual void OnVariableLiteral(ASTNode node) {}
			public virtual void OnVariableNumericLit(ASTNode node) {}
		}

		/// <summary>
		/// Walk the AST using a visitor
		/// </summary>
		public static void Visit(ParseResult result, Visitor visitor)
		{
			VisitASTNode(result.Root, visitor);
		}

		/// <summary>
		/// Walk the AST using a visitor
		/// </summary>
		public static void VisitASTNode(ASTNode node, Visitor visitor)
		{
			for (int i = 0; i < node.Children.Count; i++)
				VisitASTNode(node.Children[i], visitor);
			switch(node.Symbol.ID)
			{
				case 0x0003: visitor.OnTerminalNewLine(node); break;
				case 0x0004: visitor.OnTerminalWhiteSpace(node); break;
				case 0x0005: visitor.OnTerminalSeparator(node); break;
				case 0x0006: visitor.OnTerminalIdentifier(node); break;
				case 0x0007: visitor.OnTerminalAnnotation(node); break;
				case 0x0008: visitor.OnTerminalInlineAnnotation(node); break;
				case 0x0009: visitor.OnTerminalIntegerLiteralDecimal(node); break;
				case 0x000A: visitor.OnTerminalIntegerLiteralHexa(node); break;
				case 0x000B: visitor.OnTerminalRealLiteral(node); break;
				case 0x000C: visitor.OnTerminalBoolLiteral(node); break;
				case 0x000D: visitor.OnTerminalStringLiteral(node); break;
				case 0x000E: visitor.OnTerminalFunctionBody(node); break;
				case 0x000F: visitor.OnTerminalConstantBody(node); break;
				case 0x0010: visitor.OnTerminalRuleBody(node); break;
				case 0x0011: visitor.OnVariableRoot(node); break;
				case 0x0012: visitor.OnVariableCommentExp(node); break;
				case 0x0013: visitor.OnVariableUseDecl(node); break;
				case 0x0014: visitor.OnVariableReferenceDecl(node); break;
				case 0x0015: visitor.OnVariableConstantDecl(node); break;
				case 0x0016: visitor.OnVariableSchemaDecl(node); break;
				case 0x0017: visitor.OnVariableTypeDecl(node); break;
				case 0x0018: visitor.OnVariableBasedOnExp(node); break;
				case 0x0019: visitor.OnVariableSelectDecl(node); break;
				case 0x001A: visitor.OnVariableEntityDecl(node); break;
				case 0x001B: visitor.OnVariableEnumDecl(node); break;
				case 0x001C: visitor.OnVariableSubtypeConstDecl(node); break;
				case 0x001D: visitor.OnVariableFunctionDecl(node); break;
				case 0x001E: visitor.OnVariableStatementExp(node); break;
				case 0x001F: visitor.OnVariableLocalDecl(node); break;
				case 0x0020: visitor.OnVariableIfDecl(node); break;
				case 0x0021: visitor.OnVariableReturnStatement(node); break;
				case 0x0022: visitor.OnVariableRuleDecl(node); break;
				case 0x0023: visitor.OnVariableSupertypeDecl(node); break;
				case 0x0024: visitor.OnVariableSubtypeDecl(node); break;
				case 0x0025: visitor.OnVariableInverseDecl(node); break;
				case 0x0026: visitor.OnVariableInverseExp(node); break;
				case 0x0027: visitor.OnVariableDeriveDecl(node); break;
				case 0x0028: visitor.OnVariableDeriveExp(node); break;
				case 0x0029: visitor.OnVariableUniqueDecl(node); break;
				case 0x002A: visitor.OnVariableUniqueExp(node); break;
				case 0x002B: visitor.OnVariableAttrReadExp(node); break;
				case 0x002C: visitor.OnVariablePropDecl(node); break;
				case 0x002D: visitor.OnVariableRenamedExp(node); break;
				case 0x002E: visitor.OnVariableListDecl(node); break;
				case 0x002F: visitor.OnVariableListConcatExp(node); break;
				case 0x0030: visitor.OnVariableListConcatOpd(node); break;
				case 0x0031: visitor.OnVariableListExt(node); break;
				case 0x0032: visitor.OnVariableSetDecl(node); break;
				case 0x0033: visitor.OnVariableArrayDecl(node); break;
				case 0x0034: visitor.OnVariableBagDecl(node); break;
				case 0x0035: visitor.OnVariableArrayExp(node); break;
				case 0x0036: visitor.OnVariableOptionalDecl(node); break;
				case 0x0037: visitor.OnVariableWhereDecl(node); break;
				case 0x0038: visitor.OnVariableRuleExp(node); break;
				case 0x0039: visitor.OnVariableBoolExp(node); break;
				case 0x003A: visitor.OnVariableXorExp(node); break;
				case 0x003B: visitor.OnVariableAndExp(node); break;
				case 0x003C: visitor.OnVariableUnaryExp(node); break;
				case 0x003D: visitor.OnVariableAtomExp(node); break;
				case 0x003E: visitor.OnVariableExistsExp(node); break;
				case 0x003F: visitor.OnVariableQueryExp(node); break;
				case 0x0040: visitor.OnVariableLimitsExp(node); break;
				case 0x0041: visitor.OnVariableCompExp(node); break;
				case 0x0042: visitor.OnVariableCompOpd(node); break;
				case 0x0043: visitor.OnVariableFunctionCallExp(node); break;
				case 0x0044: visitor.OnVariableFunctionParamsExp(node); break;
				case 0x0045: visitor.OnVariableTypeofOpd(node); break;
				case 0x0046: visitor.OnVariableUsedinOpd(node); break;
				case 0x0047: visitor.OnVariableAccessOpd(node); break;
				case 0x0048: visitor.OnVariableSizeofOpd(node); break;
				case 0x0049: visitor.OnVariableClassofOpd(node); break;
				case 0x004A: visitor.OnVariableCompOp(node); break;
				case 0x004B: visitor.OnVariableEqOp(node); break;
				case 0x004C: visitor.OnVariableInOp(node); break;
				case 0x004D: visitor.OnVariableNumOp(node); break;
				case 0x004E: visitor.OnVariableLtCompOp(node); break;
				case 0x004F: visitor.OnVariableGtCompOp(node); break;
				case 0x0050: visitor.OnVariableOneofExp(node); break;
				case 0x0051: visitor.OnVariableAndorExp(node); break;
				case 0x0052: visitor.OnVariableStrConcatExp(node); break;
				case 0x0053: visitor.OnVariableListAppendExp(node); break;
				case 0x0054: visitor.OnVariableTypeId(node); break;
				case 0x0055: visitor.OnVariablePtKeyword(node); break;
				case 0x0056: visitor.OnVariableLiteral(node); break;
				case 0x0057: visitor.OnVariableNumericLit(node); break;
			}
		}
	}
}
