grammar Express {
	options {
		Axiom = "root";
		Separator = "SEPARATOR";
	}
	terminals {
		NEW_LINE -> U+000D /* CR */
					|  U+000A /* LF */
					|  U+000D U+000A /* CR LF */
					|  U+0085 // Next line character
					|  U+2028 // Line separator character
					|  U+2029; //Paragraph separator character (U+2029)
		WHITE_SPACE -> U+0020 | U+0009 | U+000B | U+000C;
		SEPARATOR   -> (WHITE_SPACE | NEW_LINE)+;
		IDENTIFIER	-> [a-zA-Z_][a-zA-Z0-9_]*;
		ANNOTATION	-> '(*' (.* - (.* '*)' .*)) '*)';
		INTEGER_LITERAL_DECIMAL -> ('0' | [1-9] [0-9]*) ([Uu] [Ll]? | [Ll] [Uu]? )? ;
		INTEGER_LITERAL_HEXA	-> '0' [xX] [a-fA-F0-9]+ ([Uu] [Ll]? | [Ll] [Uu]? )? ;
		REAL_LITERAL			-> ('0' | [1-9] [0-9]*)? '.' ('0' | [1-9] [0-9]*) ([eE] ('+'|'-')? ('0' | [1-9] [0-9]*))? [FfDdMm]?
								|  ('0' | [1-9] [0-9]*) ([eE] ('+'|'-')? ('0' | [1-9] [0-9]*)) [FfDdMm]?
								|  ('0' | [1-9] [0-9]*) [FfDdMm] ;
	}
	rules {
		numeric_lit	-> INTEGER_LITERAL_DECIMAL | INTEGER_LITERAL_HEXA | REAL_LITERAL;
		literal		-> 'true' | 'false' | numeric_lit;
		pt_keyword	-> 'STRING' | 'NUMBER' | 'BOOLEAN' | 'LOGICAL' | 'BINARY' | 'INTEGER' | 'REAL'; //Primitive type keywords
		type_id		-> (IDENTIFIER | pt_keyword)^;
		selector_exp	-> 'ONEOF' '('! IDENTIFIER (','! IDENTIFIER)+ ')'!;
		gt_comp_op	-> '>=' | '>'; //greater or equal comparison
		lt_comp_op	-> '<' | '<='; //liter or equal comparison
		num_op		-> lt_comp_op | gt_comp_op; //Numerical comparison symbols
		comp_op		-> '=' | num_op; //all comparison symbol
		not_opd		-> s_cond_exp | '('! (and_exp | or_exp) ')'!;
		not_exp		-> 'NOT'! not_opd;
		or_opd		-> s_cond_exp | not_exp;
		or_exp		-> or_opd 'OR'! or_opd ('OR'! or_opd)*;
		and_opd		-> s_cond_exp | not_exp | or_exp;
		and_exp		-> and_opd 'AND'! and_opd ('AND'! and_opd)*;
		comp_exp	-> (numeric_lit comp_op 'SELF') | ('SELF' comp_op numeric_lit);
		limits_exp	-> '{'! numeric_lit lt_comp_op 'SELF' lt_comp_op numeric_lit '}'!;
		exists_exp	-> 'EXISTS'^ '('! IDENTIFIER ')'!;
		c_cond_exp	-> not_exp | and_exp | or_exp | '('! c_cond_exp ')'!; 
		s_cond_exp	-> exists_exp | limits_exp | comp_exp | '('! s_cond_exp ')'!;
		cond_exp	-> s_cond_exp | c_cond_exp;
		where_decl	-> 'WHERE'! (IDENTIFIER ':'! cond_exp ';'!)*;
		att_decl	-> IDENTIFIER ':'! 'OPTIONAL'? type_id ';'!;
		subtype_decl	-> 'SUPERTYPE'! 'OF'! '('! selector_exp ')'!;
		supertype_decl	-> 'SUBTYPE'! 'OF'! '('! IDENTIFIER (','! IDENTIFIER)* ')'!;
		abstract_decl	-> 'ABSTRACT';
		entity_decl	-> 'ENTITY'! IDENTIFIER abstract_decl? subtype_decl? supertype_decl? ';'! att_decl* where_decl? 'END_ENTITY'! ';'!;
		select_decl	-> 'SELECT'! '('! IDENTIFIER (','! IDENTIFIER)* ')'!;
		type_decl	-> 'TYPE'! IDENTIFIER '='! (select_decl | pt_keyword) ';'! where_decl? 'END_TYPE'! ';'!;
		use_decl	-> 'USE'! 'FROM'! IDENTIFIER ';'!;
		schema_decl -> 'SCHEMA'! IDENTIFIER ';'!;
		schema_body -> schema_decl (comment_exp | use_decl | type_decl | entity_decl)*;
		comment_exp -> ANNOTATION;
		root		-> comment_exp* schema_body;
	}
}